package net.crowdin.maven;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

import net.crowdin.maven.tool.SpecialArtifact;

import org.apache.commons.io.FileUtils;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.DefaultArtifact;
import org.apache.maven.artifact.factory.ArtifactFactory;
import org.apache.maven.artifact.handler.DefaultArtifactHandler;
import org.apache.maven.artifact.metadata.ArtifactMetadataSource;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.artifact.resolver.ArtifactCollector;
import org.apache.maven.artifact.resolver.ArtifactNotFoundException;
import org.apache.maven.artifact.resolver.ArtifactResolutionException;
import org.apache.maven.artifact.resolver.ArtifactResolver;
import org.apache.maven.artifact.resolver.filter.ArtifactFilter;
import org.apache.maven.artifact.resolver.filter.ScopeArtifactFilter;
import org.apache.maven.model.Resource;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.shared.dependency.tree.DependencyNode;
import org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;
import org.apache.maven.shared.dependency.tree.DependencyTreeBuilderException;
import org.apache.maven.shared.dependency.tree.traversal.CollectingDependencyNodeVisitor;

/**
 * Aggregate the translations of this project with crowdin
 * 
 * @goal aggregate
 * @phase process-resources
 * @threadSafe
 */
public class AggregateCrowdinMojo extends AbstractCrowdinMojo {

	private static final String DEFAULT_LANG = "en";

	private static final String COMMENT = "This file is automatically generated. Please do not edit this file. "
			+ "If you'd like to change the content please use crowdin";

	/**
	 * The directory where the generated resource files will be stored. The
	 * directory will be registered as a resource root of the project such that
	 * the generated files will participate in later build phases like packaing.
	 * 
	 * @parameter expression=
	 *            "${project.build.directory}/generated-resources/messages-aggregated"
	 * @required
	 */
	private File resourceAggregatedOutputDirectory;

	/**
	 * The directory where the generated resource files will be temp stored.
	 * 
	 * @parameter expression=
	 *            "${project.build.directory}/generated-resources/messages-build"
	 * @required
	 */
	private File resourceBuildOutputDirectory;

	/**
	 * @component
	 * @required
	 * @readonly
	 */
	private ArtifactFactory artifactFactory;

	/**
	 * @component
	 * @required
	 * @readonly
	 */
	private ArtifactMetadataSource artifactMetadataSource;

	/**
	 * @component
	 * @required
	 * @readonly
	 */
	private ArtifactCollector artifactCollector;

	/**
	 * @component
	 * @required
	 * @readonly
	 */
	private DependencyTreeBuilder treeBuilder;

	/** @component */
	private ArtifactResolver resolver;

	/** @parameter default-value="${localRepository}" */
	private ArtifactRepository localRepository;

	/** @parameter default-value="${project.remoteArtifactRepositories}" */
	private List remoteRepositories;

	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		super.execute();
		resourceAggregatedOutputDirectory.mkdirs();
		resourceBuildOutputDirectory.mkdirs();

		retrieveAllProperties();
		aggregateProperties();

		Resource resource = new Resource();
		resource.setDirectory(resourceAggregatedOutputDirectory.getAbsolutePath());
		this.project.addResource(resource);
	}

	private void retrieveAllProperties() throws MojoExecutionException {
		getLog().info("Retrieving all message properties from dependencies");

		if (messagesOutputDirectory.exists()) {
			File[] listFiles = messagesOutputDirectory.listFiles();
			for (File file : listFiles) {
				if (file.isDirectory()) {
					String lang = file.getName();
					File[] properties = file.listFiles();
					for (File propertiesFile : properties) {
						if (propertiesFile.getName().endsWith(".properties")) {
							getLog().info("Adding file " + propertiesFile);

							String artifactName = project.getArtifact().toString().replace(':', '_');
							File targetProperties = new File(resourceBuildOutputDirectory, lang + "/" + artifactName + "." + propertiesFile.getName());
							try {
								FileUtils.copyFile(propertiesFile, targetProperties);
							} catch (IOException e) {
								throw new MojoExecutionException("Failed to copy " + file.getAbsolutePath() + " to " + targetProperties.getAbsolutePath(), e);
							}
						}
					}
				}
			}
		}

		Set<Artifact> dependencyArtifacts = getAllDependencies();
		Set<Artifact> unResolved = new HashSet<Artifact>();

		if (dependencyArtifacts == null) {
			getLog().info("project.getDependencyArtifacts() is null!!!");
		} else {
			for (Artifact artifact : dependencyArtifacts) {
				if (artifact.isResolved()) {
					retrievePropertiesUsingFlag(artifact);
				} else {
					unResolved.add(artifact);
				}
			}
			if (unResolved.size() > 0) {
				for (Artifact artifact : unResolved) {
					try {
						resolver.resolve(artifact, remoteRepositories, localRepository);
					} catch (ArtifactResolutionException e) {
						throw new MojoExecutionException("Failed to find " + artifact, e);
					} catch (ArtifactNotFoundException e) {
						throw new MojoExecutionException("Failed to find " + artifact, e);
					}
					retrievePropertiesUsingFlag(artifact);
				}
			}
		}
	}

	private Set<Artifact> getAllDependencies() throws MojoExecutionException {
		Set<Artifact> result = new HashSet<Artifact>();
		try {
			ArtifactFilter artifactFilter = new ScopeArtifactFilter(null);

			DependencyNode rootNode = treeBuilder.buildDependencyTree(project, localRepository, artifactFactory, artifactMetadataSource, artifactFilter,
					artifactCollector);

			CollectingDependencyNodeVisitor visitor = new CollectingDependencyNodeVisitor();

			rootNode.accept(visitor);

			List<DependencyNode> nodes = visitor.getNodes();
			for (DependencyNode dependencyNode : nodes) {
				int state = dependencyNode.getState();
				Artifact artifact = dependencyNode.getArtifact();
				if (state == DependencyNode.INCLUDED) {
					result.add(new SpecialArtifact(artifact));
				}
			}
		} catch (DependencyTreeBuilderException e) {
			throw new MojoExecutionException("Failed to get dependencies", e);
		}
		result.remove(new SpecialArtifact(project.getArtifact()));
		return result;
	}

	private void retrievePropertiesUsingFlag(Artifact artifact) throws MojoExecutionException {
		// getLog().info("Checking " + artifact.toString());

		boolean hasFlag = false;

		File artifactFile = artifact.getFile();
		if (artifactFile == null || !artifactFile.exists()) {
			getLog().info("Unable to process " + artifact);
			return;
		}
		try {
			ZipFile zipFile = new ZipFile(artifactFile);
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while (entries.hasMoreElements()) {
				ZipEntry zipEntry = (ZipEntry) entries.nextElement();

				if (!zipEntry.isDirectory()) {
					String zipEntryName = zipEntry.getName();
					int lastIndexOf = zipEntryName.lastIndexOf('/') + 1;
					String fileName = zipEntryName.substring(lastIndexOf);

					if (fileName.equals("has-messages")) {
						hasFlag = true;
					}
				}
			}
		} catch (ZipException e) {
			getLog().error("Unable to process zip " + artifactFile, e);
		} catch (IOException e) {
			getLog().error("Unable to process zip " + artifactFile, e);
		}

		if (hasFlag) {
			DefaultArtifact messagesArtifact = new DefaultArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersionRange(),
					artifact.getScope(), "zip", "crowdin", new DefaultArtifactHandler("zip"));
			if (!messagesArtifact.isResolved()) {
				try {
					resolver.resolve(messagesArtifact, remoteRepositories, localRepository);
				} catch (ArtifactResolutionException e) {
					throw new MojoExecutionException("Failed to find " + messagesArtifact, e);
				} catch (ArtifactNotFoundException e) {
					throw new MojoExecutionException("Failed to find " + messagesArtifact, e);
				}
			}
			retrieveProperties(messagesArtifact);
		}
	}

	private void retrieveProperties(Artifact artifact) {
		getLog().info("Retrieving messages from " + artifact.toString());
		File artifactFile = artifact.getFile();
		if (artifactFile == null || !artifactFile.exists() || !artifactFile.getName().endsWith(".zip")) {
			getLog().info("Unable to process " + artifact);
			return;
		}
		try {
			ZipFile zipFile = new ZipFile(artifactFile);
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while (entries.hasMoreElements()) {
				ZipEntry zipEntry = (ZipEntry) entries.nextElement();

				if (!zipEntry.isDirectory()) {
					String zipEntryName = zipEntry.getName();
					if (zipEntryName.startsWith("/")) {
						zipEntryName = zipEntryName.substring(1);
					}

					getLog().info("Found " + zipEntryName + " in " + artifact.toString());
					int slashIndex = zipEntryName.indexOf('/');
					String lang = zipEntryName.substring(0, slashIndex);
					zipEntryName = zipEntryName.substring(slashIndex + 1);

					String artifactName = artifact.toString().replace(':', '_');
					File targetProperties = new File(resourceBuildOutputDirectory, lang + "/" + artifactName + "_" + zipEntryName);

					InputStream inputStream = zipFile.getInputStream(zipEntry);
					copyToFile(inputStream, targetProperties);
				}
			}
		} catch (ZipException e) {
			getLog().error("Unable to process zip " + artifactFile, e);
		} catch (IOException e) {
			getLog().error("Unable to process zip " + artifactFile, e);
		}

	}

	private void copyToFile(InputStream stream, File targetFile) throws IOException {
		BufferedOutputStream fOut = null;
		try {
			targetFile.getParentFile().mkdirs();
			fOut = new BufferedOutputStream(new FileOutputStream(targetFile));
			byte[] buffer = new byte[32 * 1024];
			int bytesRead = 0;
			while ((bytesRead = stream.read(buffer)) != -1) {
				fOut.write(buffer, 0, bytesRead);
			}
		} catch (Exception e) {
			targetFile.delete();
			throw new IOException(e);
		}
		fOut.close();
		stream.close();
	}

	private void aggregateProperties() throws MojoExecutionException {
		getLog().info("Aggregating all message properties from dependencies");

		String[] langFolders = resourceBuildOutputDirectory.list();

		Properties defaultProperties = new Properties();

		for (String langFolder : langFolders) {
			if (langFolder.equals(DEFAULT_LANG)) {
				File langFold = new File(resourceBuildOutputDirectory, langFolder);
				defaultProperties.putAll(aggregatePropertiesFolder(langFold, langFolder, null));
			}
		}

		for (String langFolder : langFolders) {
			if (!langFolder.startsWith(".") && !langFolder.equals(DEFAULT_LANG)) {
				File langFold = new File(resourceBuildOutputDirectory, langFolder);
				if (langFold.isDirectory()) {
					aggregatePropertiesFolder(langFold, langFolder, defaultProperties);
				}
			}
		}
	}

	private Properties aggregatePropertiesFolder(File langFolder, String lang, Properties defaultProperties) throws MojoExecutionException {
		Properties properties = new Properties();
		if (defaultProperties != null) {
			properties.putAll(defaultProperties);
		}

		File[] propFiles = langFolder.listFiles();
		for (File file : propFiles) {
			Properties someProperties = new Properties();
			try {
				InputStream inStream = new FileInputStream(file);
				someProperties.load(inStream);
				inStream.close();
			} catch (IOException e) {
				throw new MojoExecutionException("Failed to load " + file, e);
			}
			properties.putAll(someProperties);
		}

		getLog().info("Aggregate properties for lang " + lang);
		File propertiesFile = new File(resourceAggregatedOutputDirectory, "messages_" + lang + ".properties");
		try {
			propertiesFile.getParentFile().mkdirs();
			FileOutputStream out = new FileOutputStream(propertiesFile);
			properties.store(out, COMMENT);
			out.close();
		} catch (IOException e) {
			throw new MojoExecutionException("Failed to save " + propertiesFile, e);
		}

		return properties;
	}

}
